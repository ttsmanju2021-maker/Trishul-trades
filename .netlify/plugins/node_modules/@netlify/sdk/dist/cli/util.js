import fs from "node:fs/promises";
import fss from "node:fs";
import os from "node:os";
import path from "node:path";
import chalk from "chalk";
export const getExtensionModule = async (builtPath, directory = process.cwd()) => {
    try {
        const extensionModule = await import(builtPath);
        const { extension, integration } = extensionModule;
        if (!extension) {
            const { sourceFilePath } = await getExtensionBuildInfo({
                cwd: directory,
            });
            throw new Error(`Your extension must be a named export in your main TS file (at ${sourceFilePath}).

For example:

import { NetlifyExtension } from "@netlify/sdk";
const extension = new NetlifyExtension();

export { extension } // <-- this is required.

${integration ? `Found a deprecated "integration" export in this file. Please rename this export to "extension"` : ``}`);
        }
        return extension;
    }
    catch (e) {
        console.log(chalk.red("Could not load module"));
        if (e.message) {
            console.error(e.message);
        }
        throw e;
    }
};
export const getExtensionBuildInfo = async ({ cwd, outDirOveride, }) => {
    const extensionPackageJson = JSON.parse(await fs.readFile(path.resolve(cwd, "package.json"), "utf8"));
    // main points to our entrypoint
    const { main } = extensionPackageJson;
    if (!main) {
        throw new Error(`${extensionPackageJson.name || `package`} must set a "main" property in package.json`);
    }
    const sourceFilePath = path.resolve(cwd, main);
    if (!fss.existsSync(sourceFilePath)) {
        throw new Error(`${extensionPackageJson.name || `package`}'s main property in package.json points to a non-existing file`);
    }
    const outDir = outDirOveride || path.resolve(`${cwd}/.ntli`);
    const builtPath = `${outDir}/index.js`;
    const packageName = extensionPackageJson.name;
    return {
        extensionPackageJson,
        sourceFilePath,
        builtPath,
        outDir,
        packageName,
    };
};
export function getDepNames(packageJsonContents) {
    const deps = {
        ...(packageJsonContents.dependencies || {}),
        ...(packageJsonContents.devDependencies || {}),
    };
    return Object.keys(deps);
}
export function removeBundledDepsFromPackageJsonContents(packageJsonContents, importedNodeModules) {
    function removeExtraDeps(deps) {
        return Object.fromEntries(Object.entries(deps || {}).filter(([depName]) => {
            return (
            // if no imported modules list is provided, include all deps
            !importedNodeModules?.size ||
                // if it is, then only include the dep if it's been imported somewhere
                importedNodeModules.has(depName));
        }));
    }
    return {
        ...packageJsonContents,
        dependencies: removeExtraDeps(packageJsonContents.dependencies),
        devDependencies: removeExtraDeps(packageJsonContents.devDependencies),
    };
}
export const getSettings = () => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    if (!fss.existsSync(settingsPath)) {
        return {};
    }
    return JSON.parse(fss.readFileSync(settingsPath, "utf8"));
};
export const updateSettings = (newSettings) => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    const settings = {
        ...(getSettings() || {}),
        ...newSettings,
    };
    ensureFileSync(settingsPath);
    fss.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
};
export const ensureFile = async (file) => {
    let stats;
    try {
        stats = await fs.stat(file);
    }
    catch {
        // Ignore error
    }
    if (stats !== undefined && stats.isFile()) {
        return;
    }
    const dir = path.dirname(file);
    let dirStats = null;
    try {
        dirStats = await fs.stat(dir);
    }
    catch (err) {
        // if the directory doesn't exist, make it
        if (err instanceof Error && "code" in err && err.code === "ENOENT") {
            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(file, "");
            return;
        }
        else {
            throw err;
        }
    }
    if (dirStats.isDirectory()) {
        await fs.writeFile(file, "");
    }
    else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        await fs.readdir(dir);
    }
};
export const ensureFileSync = async (file) => {
    let stats;
    try {
        stats = fss.statSync(file);
    }
    catch {
        // Ignore error
    }
    if (stats !== undefined && stats.isFile()) {
        return;
    }
    const dir = path.dirname(file);
    try {
        if (!fss.statSync(dir).isDirectory()) {
            // parent is not a directory
            // This is just to cause an internal ENOTDIR error to be thrown
            fss.readdirSync(dir);
        }
    }
    catch (err) {
        // If the stat call above failed because the directory doesn't exist, create it
        if (err instanceof Error && "code" in err && err.code === "ENOENT") {
            fss.mkdirSync(dir, { recursive: true });
        }
        else {
            throw err;
        }
    }
    fss.writeFileSync(file, "");
};
//# sourceMappingURL=util.js.map